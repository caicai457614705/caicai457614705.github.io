{"meta":{"title":"汪星人的博客","subtitle":null,"description":null,"author":"王志鹏","url":"http://yoursite.com"},"pages":[{"title":"I think, therefore I am","date":"2017-05-10T12:58:11.000Z","updated":"2017-05-11T06:03:30.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人简介武汉人,现居杭州,15年毕业,还处于用轮子阶段的java开发,前端略懂。"}],"posts":[{"title":"SpringCloud网关角色-Zuul","slug":"cloud_zuul","date":"2017-05-19T03:01:10.000Z","updated":"2017-05-19T03:01:10.000Z","comments":true,"path":"2017/05/19/cloud_zuul/","link":"","permalink":"http://yoursite.com/2017/05/19/cloud_zuul/","excerpt":"","text":"SpringBoot网关——ZuulZuul简介Zuul的主要功能是路由和过滤器。路由功能是微服务的一部分，比如／api/user映射到user服务，/api/shop映射到shop服务。zuul实现了负载均衡。zuul有以下功能 Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 依赖添加1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 服务提供在其入口applicaton类加上注解@EnableZuulProxy，开启zuul：123456789@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class ServiceZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceZuulApplication.class, args); &#125;&#125; 配置文件（这个很重要）定义他的zone, 服务端口， 名称， 路由规则等等1234567891011121314151617eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8769spring: application: name: service-zuulzuul: routes: api-a: path: /api-a/** serviceId: service-ribbon api-b: path: /api-b/** serviceId: service-feign 服务过滤zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class MyFilter extends ZuulFilter&#123; private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() &#123; return &quot;pre&quot;; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(&quot;%s &gt;&gt;&gt; %s&quot;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(&quot;token&quot;); if(accessToken == null) &#123; log.warn(&quot;token is empty&quot;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write(&quot;token is empty&quot;); &#125;catch (Exception e)&#123;&#125; return null; &#125; log.info(&quot;ok&quot;); return null; &#125;&#125; filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://yoursite.com/tags/学习总结/"},{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"SpringCloud服务注册和发现","slug":"cloud_regist","date":"2017-05-19T02:42:25.000Z","updated":"2017-05-19T02:42:25.000Z","comments":true,"path":"2017/05/19/cloud_regist/","link":"","permalink":"http://yoursite.com/2017/05/19/cloud_regist/","excerpt":"","text":"微服务架构 服务注册中心（相当于zookeeper） 创建启动类，添加EurekaServer标记 12345678@EnableEurekaServer@SpringBootApplicationpublic class EurekaserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaserverApplication.class, args); &#125;&#125; eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml： 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 访问http://localhost:8761即可看到控制界面 服务提供者(当然也是可以当消费者的) 创建工程方式基本一样，就依赖改一下 123456//spring-cloud-starter-eureka-server换成spring-cloud-starter-eureka &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; 用@EnableEurekaClient标注是服务提供者 1234567891011121314151617@SpringBootApplication@EnableEurekaClient@RestControllerpublic class ServiceHiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceHiApplication.class, args); &#125; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @RequestMapping(&quot;/hi&quot;) public String home(@RequestParam String name) &#123; return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port; &#125;&#125; 同时还要配置，注册时的所在域，是之前的服务中心，并且指定要提供的服务的名字 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8762spring: application: name: service-hi","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://yoursite.com/tags/学习总结/"},{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"SpringCloud服务消费","slug":"cloud_consume","date":"2017-05-19T02:31:13.000Z","updated":"2017-05-19T02:31:13.000Z","comments":true,"path":"2017/05/19/cloud_consume/","link":"","permalink":"http://yoursite.com/2017/05/19/cloud_consume/","excerpt":"","text":"Feign简介Feign是一个声明式的web服务客户端，它使得写web服务变得更简单。使用Feign,只需要创建一个接口并注解。它具有可插拔的注解特性，包括Feign 注解和JAX-RS注解。Feign同时支持可插拔的编码器和解码器。spring cloud对Spring mvc添加了支持，同时在spring web中次用相同的HttpMessageConverter。当我们使用feign的时候，spring cloud 整和了Ribbon和eureka去提供负载均衡。创建feign工程 相对于之前的服务多加一个feign依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件就换了个name ,表示这是另一个服务，然后消费之前注册的服务,同理另外一个服务也可以用同样的方式消费该服务 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8765spring: application: name: service-feign 在程序的入口类，需要通过注解@EnableFeignClients来开启feign: 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125; 定义一个feign接口类,通过@ FeignClient（“服务名”），来指定调用哪个服务： 12345@FeignClient(value = &quot;service-hi&quot;)public interface SchedualServiceHi &#123; @RequestMapping(value = &quot;/hi&quot;,method = RequestMethod.GET) String sayHiFromClientOne(@RequestParam(value = &quot;name&quot;) String name);&#125; web层使用服务 12345678910@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @RequestMapping(value = &quot;/hi&quot;,method = RequestMethod.GET) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 可以指定服务的配置类 1234@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)public interface StoreClient &#123; //..&#125; 重写配置,定制服务（先了解以后研究） 123456789101112@Configurationpublic class FooConfiguration &#123; @Bean public Contract feignContractg() &#123; return new feign.Contract.Default(); &#125; @Bean public BasicAuthRequestInterceptor basicAuthRequestInterceptor() &#123; return new BasicAuthRequestInterceptor(&quot;user&quot;, &quot;password&quot;); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://yoursite.com/tags/学习总结/"},{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"Consumer源码笔记","slug":"kafka_consumer","date":"2017-05-10T09:20:50.000Z","updated":"2017-05-10T11:50:20.000Z","comments":true,"path":"2017/05/10/kafka_consumer/","link":"","permalink":"http://yoursite.com/2017/05/10/kafka_consumer/","excerpt":"","text":"Consumer源码笔记一.ConsumerConfig创建consumer，主要是传递配置,keyDerializer和valueDerializer类，然后consumer中有一个private构造方法，会用配置文件创建一个consumerConfig，来真正的初始化KafkaConsumer，而这个consumerConfig中呢，主要是2个东西，一个是ConfigDef CONFIG这个类主要是用来定义配置项的名字，类型，默认值，以及解释文档，另外一个东西就是originals,这个参数是在父类AbstractConfig中的，这个才是你真正自己传进来的参数AbstractConfig类会解析这个map,通过definition.parse方法解析到values这个map中存起来备用。 二.Consumer初始化过程可以查看Consumer的源码，里面有很多基本参数，配置中那些比较有用的都有，还有几个重要的如下： ConsumerCoordinator:kafka均衡负载器 Fetcher: 很重要的消息收发角色,发送抓取请求，处理和缓存抓取的数据就靠这个类 Metrics：用于监控kafka的一些测量指标 Metadata: 存放原信息的类 ChannelBuilder: 怎么看都是创建KafkaChannel的的类 ConsumerNetworkClient:很重要的消息收发角色，暂时还没看,主要是处理netword IO的 三.consumer方法解读 consumer中的poll 123456789101112131415do &#123;//拉取一次 Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollOnce(remaining); if (!records.isEmpty()) &#123; //在返回这次拉取到的数据之前，就可以开始下一轮的拉取,由于这次拉取我们必须返回这次拉取的数据，并且offset也更新到了相应位置，所以我们需要disables wakeups和delayed task execution(我也不太明白其作用,╮(╯▽╰)╭) //发起拉取请求，并且poll数据，在pullonce中也有 fetcher.initFetches(metadata.fetch()); client.quickPoll(); return new ConsumerRecords&lt;&gt;(records); &#125; long elapsed = time.milliseconds() - start; remaining = timeout - elapsed; &#125; while (remaining &gt; 0); pollOnce其中有几个重要的方法: fetchedRecords:这个方法其实只是把缓存在fetcher中的records遍历出来放到一个list里面，并且更新每个topicPartion中的offset，然后清空这个缓存records的list initFetches: 在这个方法中会创建对kafka集群中节点的消息抓取请求,然后在client.send中add一个listener来支持回调，回调成功时，处理response,在处理过程中就会将抓取到的消息缓存到fetcher的recordsList中 poll,quickpoll这些还真没看明白","categories":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/categories/Kafka/"}],"tags":[{"name":"源码笔记","slug":"源码笔记","permalink":"http://yoursite.com/tags/源码笔记/"},{"name":"原创","slug":"原创","permalink":"http://yoursite.com/tags/原创/"}]},{"title":"Producer源码笔记","slug":"kafka_producer","date":"2017-05-10T09:20:49.000Z","updated":"2017-05-10T11:49:42.000Z","comments":true,"path":"2017/05/10/kafka_producer/","link":"","permalink":"http://yoursite.com/2017/05/10/kafka_producer/","excerpt":"","text":"Producer源码笔记一.ProducerConfig创建producer，主要是传递配置,keySerializer和valueSerializer类，然后Producer中有一个private构造方法，会用配置文件创建一个producerConfig，来真正的初始化KafkaProducer，而这个producerConfig中呢，主要是2个东西，一个是ConfigDef CONFIG这个类主要是用来定义配置项的名字，类型，默认值，以及解释文档，另外一个东西就是originals,这个参数是在父类AbstractConfig中的，这个才是你真正自己传进来的参数AbstractConfig类会解析这个map,通过definition.parse方法解析到values这个map中存起来备用。 二.Producer初始化过程可以查看Producer的源码，里面有很多基本参数，配置中那些比较有用的都有，还有几个重要的如下： sender: 真正用于触发（真正发的是KafkaChannel）producer发送消息的地方，是runable类型 ioThread: 查看源码，可以看到他会将sender作为入参，创建一个线程，并且启动，从构造函数里面可以看出这是一个守护线程 123String ioThreadName = \"kafka-producer-network-thread\" + (clientId.length() &gt; 0 ? \" | \" + clientId : \"\"); this.ioThread = new KafkaThread(ioThreadName, this.sender, true); this.ioThread.start(); Metrics：用于监控kafka的一些测量指标 Metadata: 存放原信息的类 accumulator: 用于积累batch数据的类 partitioner: 用于分区的class ,默认的defaultPationer 三.send方法解读平时常用的send,真正调用的是下面这个方法,callback传null而已1send(ProducerRecord&lt;K, V&gt; record， Callback callback) 方法流程如下: 取元信息 然后对key,value序列化 partion方法分配分区 计算序列化后消息的长度,并去检查是否大于maxRequestSize和totalMemorySize accumulator.append积累消息并且去batch,返回一个RecordAppendResult 12345//检查result中属性，如果是新批次或者批次已满，就唤醒sender线程去发送消息，之前都是block状态等待I/Oif (result.batchIsFull || result.newBatchCreated) &#123; log.trace(\"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch\", record.topic(), partition); this.sender.wakeup(); &#125; result.future最后返回一个future,这个是FutureRecordMetadata类型的future(从哪里来待学习)","categories":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/categories/Kafka/"}],"tags":[{"name":"源码笔记","slug":"源码笔记","permalink":"http://yoursite.com/tags/源码笔记/"},{"name":"原创","slug":"原创","permalink":"http://yoursite.com/tags/原创/"}]},{"title":"想读的书","slug":"to_read","date":"2017-05-10T07:06:54.000Z","updated":"2017-05-10T11:50:07.000Z","comments":true,"path":"2017/05/10/to_read/","link":"","permalink":"http://yoursite.com/2017/05/10/to_read/","excerpt":"","text":"洞察互联网的二十本数 互联网的本质 知识的边界 大数据时代：生活、工作与思维的大变革 智能时代 科技想要什么 技术至死 互联网思想十讲 数字化生存 信息的社会层面 链接：网络新科学 硅谷百年史 信息规则 长尾理论 认知盈余：自由时间的力量 区块链革命 信息就是信息：布隆伯格自述 搜 Facebook效应 游戏改变世界：游戏化如何让世界更美好 创业无畏 手机：挡不住的呼唤 小块送三组合 管理学数据 管理学 组织行为学 营销管理 人力资源管理 科普向 隐藏的宇宙：平行宇宙是什么 大学生书单 大金融论纲 美国货币史 别闹了，费曼先生 数学之美 怀疑的化学家 化学元素的发现 这才是心理学：看穿伪心理学的本质 骗局 增肌塑性指南 幸福课 走，吃火锅 深度学习的艺术 我在美国学游戏设计 建筑迷城 策略:博弈论导论","categories":[{"name":"阅读","slug":"阅读","permalink":"http://yoursite.com/categories/阅读/"}],"tags":[{"name":"想做的事","slug":"想做的事","permalink":"http://yoursite.com/tags/想做的事/"}]}]}